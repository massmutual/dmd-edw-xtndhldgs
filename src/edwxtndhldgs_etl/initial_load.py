"""Initial Load. At this moment I."""

import vertica_python

import utility_mixins as mix

from generic_etl.common.vertica_utils import VerticaUtils as v


class EdwXtndhldgsETLInitialLoad(mix.LoggingMixin, mix.PathMixin):
    """EDW-XTNDHLDGS initial load application."""

    _logger_name = __name__.split(".")[0]

    def __init__(
        self,
        db_host: str,
        db_port: int,
        db_name: str,
        db_user: str,
        db_password: str,
        init_load_list: str,
        init_load_type: str,
        init_load_restart: bool = False,
        debug_mode: bool = False,

    ) -> None:
        """Generate a EdwXtndhldgsETLInitialLoad object.

        :param db_host: edw server hostname.
        :param db_port: edw server port number.
        :param db_name: edw database name.
        :param db_user: edw batch user for this project.
        :param db_password: password for the edw batch user.
        :param init_load_list: table list for processing.
        :param init_load_type: either using run_id/trans_id for looping.
        :param init_load_restart: Boolean input If true will truncate snapshot table(For handling restarting process)
        :param debug_mode: split bulk transform statements(in SQL file) to run individually for easier troubleshooting.
        """

        self.conn_info = {
            "host": db_host,
            "port": db_port,
            "user": db_user,
            "password": db_password,
            "database": db_name,
            # autogenerated session label by default,
            "session_label": "some_label",
            # default throw error on invalid UTF-8 results
            "unicode_error": "strict",
            # SSL is disabled by default
            "ssl": True,
            # using server-side  prepared statements is disabled by default
            "use_prepared_statements": False,
        }

        self.debug_mode = debug_mode
        self.init_load_list = init_load_list
        self.init_load_type = init_load_type
        self.init_load_restart = init_load_restart

    def get_connection(self):
        """Create a Vertica connection from the given connection information."""
        return vertica_python.connect(**self.conn_info)

    def run_initial_load_by_run_ID(self, table_name, init_load_restart):
        """Execute single dim table initial load."""
        sql_path_prefix = str(self.get_internal_path(__name__.split(".")[0], "sql/initial_load/work_load/"))
        sql_path_prefix = f"{sql_path_prefix}/{table_name}/"
        get_run_id_from_tables = f"{sql_path_prefix}1-get_run_id.sql"
        truncate_tables = f"{sql_path_prefix}2-truncate_tables.sql"
        with self.get_connection() as conn:
            run_id_lst = [k["RUN_ID"] for k in v.run_query_from_sql_file(conn, get_run_id_from_tables, {})]
            run_id_lst.sort()
            # Added logic -> Don't truncate if we are restarting the job
            if init_load_restart == "False":
                v.run_query_from_sql_file(conn, truncate_tables, {}, with_commit=True)
            else:
                self.info(f"--Restart flag is True, Skipping 2nd Step")
            initial_load_sqls = [
                f"{sql_path_prefix}{s}"
                for s in ("3-build_snapshot.sql", "4-snapshot_to_work.sql", "5-work_to_core.sql")
            ]
            for run_id in run_id_lst:
                self.info(f"--Loading with run_id {run_id}")
                for sql in initial_load_sqls:
                    self.info(f"Loading {sql} with run_id {run_id}")
                    v.run_query_from_sql_file(
                        conn, sql, {"RUN_ID": run_id}, loop_statements=self.debug_mode, with_commit=True
                    )

    def run_initial_load_by_trans_date(self, table_name, init_load_restart):
        """Execute single fact table initial load."""
        sql_path_prefix = str(self.get_internal_path(__name__.split(".")[0], "sql/initial_load/work_load/"))
        sql_path_prefix = f"{sql_path_prefix}/{table_name}/"
        get_trans_dt_from_tables = f"{sql_path_prefix}1-get_trans_dt.sql"
        truncate_tables = f"{sql_path_prefix}2-truncate_tables.sql"
        with self.get_connection() as conn:
            trans_dt_lst = [k["TRANS_DT"] for k in v.run_query_from_sql_file(conn, get_trans_dt_from_tables, {})]
            trans_dt_lst.sort()
            # Added logic -> Don't truncate if we are restarting the job
            if init_load_restart == "False":
                v.run_query_from_sql_file(conn, truncate_tables, {}, with_commit=True)
            else:
                self.info(f"--Restart flag is True, Skipping 2nd Step")
            initial_load_sqls = [
                f"{sql_path_prefix}{s}"
                for s in ("3-build_snapshot.sql", "4-snapshot_to_work.sql", "5-work_to_core.sql")
            ]
            for trans_dt in trans_dt_lst:
                self.info(f"--Loading with trans_dt {trans_dt}")
                for sql in initial_load_sqls:
                    self.info(f"Loading {sql} with trans_dt {trans_dt}")
                    v.run_query_from_sql_file(
                        conn, sql, {"TRANS_DT": trans_dt}, loop_statements=self.debug_mode, with_commit=True
                    )

    def run(self):
        """Execute the initial load sql."""

        table_list = self.init_load_list
        process_type = self.init_load_type
        restart_flag = self.init_load_restart

        if process_type.lower() == 'r':
        #     run by run_id
            for table in table_list:
                self.info(f"--Start loading table by Run_ID: {table}")
                self.run_initial_load_by_run_ID(table, init_load_restart=restart_flag)

        elif process_type.lower() == 't':
        #     run by trans_dt
            for table in table_list:
                self.info(f"--Start loading table by Trans_ID: {table}")
                self.run_initial_load_by_trans_date(table, init_load_restart=restart_flag)



